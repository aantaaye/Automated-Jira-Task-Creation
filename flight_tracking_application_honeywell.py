# Name: Puneet Kumar
# Roll number: SM24MTECH14008
# -*- coding: utf-8 -*-
"""flight_tracking_application_honeywell.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SoGjxmfXwODWG7iAHtGKWBIMTx4oak8M
"""



import requests
from requests.auth import HTTPBasicAuth
import json
import time
import google.generativeai as genai

# === Authentication Configuration ===
USER_EMAIL = "jyotsnasharma3333@gmail.com"
TOKEN = "ATATT3xFfGF0pDmMd1_jHq9OU_khdIBb50MMZ9fB_TPLoQGZDjQ8ze5wDesqbgf7Iwn_aFJO9nwvC2usDY6lnV4efBQetYENHQZldwPcBQHEmuf4N3dGEABvlriw40Y9Z71j0pQoHwrBuyoIF8fi21oIqdOjAQ8HlL_pRSnrXBnogr6JyzqG_1o=429CB145"
JIRA_URL = "https://jyotsnasharma3333.atlassian.net"
PROJ_KEY = "FTS"

authentication = HTTPBasicAuth(USER_EMAIL, TOKEN)
http_headers = {
    "Accept": "application/json",
    "Content-Type": "application/json"
}

# === AI Model Configuration ===
available_keys = ['AIzaSyCw6sWPxQ5IuGMYFhqvdZdwWK5rT5FF7XE', 'AIzaSyD68FROsKWYOwjDn-No_vq_itVq0_YMgfM',
                 "AIzaSyD-m1VxU3v-ay6kwUz4Gq9awwSoDKqTB9U", "AIzaSyAe9qA3_D0OPCGBVav7-wJdcHtHgrpmFfI"]
active_key_index = 0

def initialize_ai_model():
    """
    Set up the AI model with the current API key.
    """
    global active_key_index
    selected_key = available_keys[active_key_index]
    genai.configure(api_key=selected_key)
    return genai.GenerativeModel('gemini-1.5-pro-latest')

def request_ai_completion(instruction_text):
    """
    Request content from AI model with fallback mechanism.
    """
    global active_key_index
    starting_index = active_key_index
    try_count = 0

    while try_count < len(available_keys):
        try:
            ai_instance = initialize_ai_model()
            ai_response = ai_instance.generate_content(instruction_text)
            return ai_response.text

        except Exception as error:
            print(f"Key {available_keys[active_key_index]} failed: {error}")
            if '429' in str(error) or 'quota' in str(error):
                time.sleep(1)

            active_key_index = (active_key_index + 1) % len(available_keys)
            try_count += 1

            if active_key_index == starting_index:
                time.sleep(2)

    raise Exception("All API keys exhausted after multiple attempts")

# === Jira Ticket Operations ===
def add_ticket(title, details):
    endpoint = f"{JIRA_URL}/rest/api/3/issue"
    data = {
        "fields": {
            "project": {"key": PROJ_KEY},
            "summary": title,
            "description": {
                "type": "doc",
                "version": 1,
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "text",
                                "text": details
                            }
                        ]
                    }
                ]
            },
            "issuetype": {"name": "Task"},
            "assignee": {"id": "712020:6ad7fe19-fe66-40da-be35-22193f03bb02"}
        }
    }
    response = requests.post(endpoint, headers=http_headers, json=data, auth=authentication)
    if response.status_code == 201:
        ticket_id = response.json()["key"]
        print(f"Created ticket: {ticket_id}")
        return ticket_id
    else:
        print("Ticket creation failed:")
        print(response.status_code, response.text)
        return None

def add_subtask(parent_id, title, details):
    endpoint = f"{JIRA_URL}/rest/api/3/issue"
    data = {
        "fields": {
            "project": {"key": PROJ_KEY},
            "parent": {"key": parent_id},
            "summary": title,
            "description": {
                "type": "doc",
                "version": 1,
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "text",
                                "text": details
                            }
                        ]
                    }
                ]
            },
            "issuetype": {"name": "Sub-task"},
            "assignee": {"id": "712020:6ad7fe19-fe66-40da-be35-22193f03bb02"}
        }
    }
    response = requests.post(endpoint, headers=http_headers, json=data, auth=authentication)
    if response.status_code == 201:
        subtask_id = response.json()["key"]
        print(f"Created subtask: {subtask_id} under parent {parent_id}")
        return subtask_id
    else:
        print(f"Subtask creation failed under {parent_id}:")
        print(response.status_code, response.text)
        return None

def retrieve_tickets():
    endpoint = f"{JIRA_URL}/rest/api/3/search"
    query_params = {
        "jql": f"project={PROJ_KEY} AND key NOT IN (CPG-1, CPG-2)",
        "maxResults": 50,
        "fields": "summary,status,assignee"
    }
    response = requests.get(endpoint, headers=http_headers, params=query_params, auth=authentication)
    if response.status_code == 200:
        results = response.json().get("issues", [])
        print(f"\nFound {len(results)} tickets:\n")
        for item in results:
            item_id = item["key"]
            item_title = item["fields"]["summary"]
            item_status = item["fields"]["status"]["name"]
            item_owner = item["fields"]["assignee"]["displayName"] if item["fields"]["assignee"] else "Unassigned"
            print(f"{item_id}: {item_title} [Status: {item_status}] (Assigned to: {item_owner})")
        return results

# === AI Task Generation Functions ===
def generate_tasks(requirement_text):
    """
    Use AI to break down a software requirement into development subtasks.
    """
    instruction = f"""Carefully review the software development task described below and create EXACTLY 3 to 5 unique, high-level subtasks:
    Task: {requirement_text}

    Guidelines:
    1. Create exactly 3 to 5 subtasks—no more, no less. This is a strict requirement.
    2. Each subtask should focus on a major development area or phase of the work.
    3. Subtasks must be unique and distinct from one another, with no overlap in scope.
    4. Avoid splitting the same component into multiple subtasks—each one should target a different aspect of development.
    5. Ensure each subtask involves a significant amount of work, representing a standalone unit of progress.
    6. At the same time, keep each subtask specific enough to be clearly actionable and understandable.
    7. Try to cover multiple facets of development, such as backend, frontend, testing, DevOps, or API integration, if applicable.
    8. Clearly label each subtask with its category: Backend, Frontend, API, DevOps, or Testing.
    9. Suggest a relevant name for the module or component that the subtask relates to.
    10. Write a concise summary for each subtask that explains what it entails in under 100 words.
    11. Provide a short, clear title for each subtask that can serve as a Jira ticket name.

Return the result in the following JSON format:
[
  {{
    "summary": "Brief explanation of the subtask (max 100 words)",

    "title": "Concise Jira ticket title"
  }}
]

IMPORTANT: Verify that all subtasks are clearly distinct from each other before finalizing. The total number of subtasks MUST be between 3 and 5—no exceptions.
"""


    ai_output = request_ai_completion(instruction)

    try:
        json_start = ai_output.find('[')
        json_end = ai_output.rfind(']') + 1

        if json_start >= 0 and json_end > json_start:
            json_text = ai_output[json_start:json_end]
            return json.loads(json_text)
        else:
            return json.loads(ai_output)
    except json.JSONDecodeError as e:
        print(f"JSON parsing error: {e}")
        print(f"Raw AI response: {ai_output}")
        return None

# === Link Management Functions ===
def fetch_link_types():
    """Retrieve available issue link types"""
    endpoint = f"{JIRA_URL}/rest/api/3/issueLinkType"
    response = requests.get(endpoint, headers=http_headers, auth=authentication)

    if response.status_code == 200:
        available_types = response.json().get("issueLinkTypes", [])
        print("\nAvailable link types:")
        for link_type in available_types:
            print(f"  - {link_type['name']} (inward: {link_type['inward']}, outward: {link_type['outward']})")
        return available_types
    else:
        print("Failed to retrieve link types:")
        print(response.status_code, response.text)
        return []

def connect_issues(source_issue, target_issue, relationship="Relates"):
    """Create a link between two issues"""
    endpoint = f"{JIRA_URL}/rest/api/3/issueLink"

    data = {
        "outwardIssue": {"key": source_issue},
        "inwardIssue": {"key": target_issue},
        "type": {"name": relationship}
    }

    print(f"Sending link request: {json.dumps(data)}")

    response = requests.post(endpoint, headers=http_headers, json=data, auth=authentication)

    if response.status_code == 201:
        print(f"Successfully linked {source_issue} and {target_issue} with type '{relationship}'")
        return True
    else:
        print(f"Failed to link issues {source_issue} and {target_issue}:")
        print(f"   Status code: {response.status_code}")
        print(f"   Response: {response.text}")
        return False

# === Task Creation Functions ===
def create_task_hierarchy(parent_id, tasks):
    """Create tickets for tasks and link them to parent"""
    created_tickets = []
    task_metadata = {}

    # Get available link types
    relationship_types = fetch_link_types()

    # Define standard link types to try
    common_link_types = ["Relates", "Relates to", "Dependency", "Parent/Child", "Blocks"]
    available_names = [rt["name"] for rt in relationship_types]

    # Select appropriate link type
    selected_link_type = None
    for link_name in common_link_types:
        if link_name in available_names:
            selected_link_type = link_name
            break

    if not selected_link_type and relationship_types:
        selected_link_type = relationship_types[0]["name"]

    if not selected_link_type:
        print("No link types available, creating tickets without linking")
    else:
        print(f"Using link type: {selected_link_type}")

    for idx, task in enumerate(tasks):
        # Format description with metadata
        full_description = (f"{task['summary']}\n\n"
                      f"Parent Task: {parent_id}")

        # Create the task ticket
        ticket_id = add_ticket(task["title"], full_description)

        if ticket_id:
            created_tickets.append(ticket_id)
            task_metadata[ticket_id] = task

            # Create relationship to parent
            if selected_link_type:
                print(f"Linking {ticket_id} to {parent_id}...")
                time.sleep(1)
                success = connect_issues(parent_id, ticket_id, selected_link_type)

                # Try alternate link type if first fails
                if not success and len(relationship_types) > 1:
                    print("First link attempt failed, trying alternative link type...")
                    time.sleep(1)
                    alternate_type = relationship_types[1]["name"]
                    connect_issues(parent_id, ticket_id, alternate_type)

    return created_tickets, task_metadata

# === Test Case Generation Functions ===

def create_test_cases(task_details, task_id):
    """
    Generate and document test cases for the given task.
    """
    instruction = f"""Based on the development task below, generate EXACTLY 3 to 5 well-defined test cases:

   Task Description: {task_details}

      Guidelines:
      1. Provide exactly 3 to 5 test cases—strictly within this range.
      2. Each test case should target a key functionality, feature, or user interaction described in the task.
      3. Include at least one test that covers an edge case or uncommon scenario.
      4. Make sure every test case is detailed enough to be directly executable by a QA engineer or automated test system.
      5. Clearly describe each step required to perform the test case.
      6. State the expected outcome for each test, including specific acceptance criteria.
      7. Focus on variety—test different parts of the system rather than repeating similar tests.
      8. Ensure all test cases provide meaningful value and are not overly basic or redundant.

      Format your output as a JSON array using the structure below:
      [
        {{
          "test_id": "TC-1",
          "test_name": "Concise and descriptive title",
          "description": "Detailed explanation of what the test covers",
          "steps": ["Step 1", "Step 2", "Step 3"],
          "expected_result": "The outcome expected if the functionality works correctly",
          "priority": "High | Medium | Low"
        }}
      ]

      NOTE: Ensure all test cases are distinct and thoughtfully crafted. You must submit exactly 3 to 5 test cases—no more, no less.
      """

    print(f"\nGenerating test cases for task {task_id}...")
    ai_output = request_ai_completion(instruction)

    created_items = []

    try:
        # Extract JSON from response
        json_start = ai_output.find('[')
        json_end = ai_output.rfind(']') + 1

        if json_start >= 0 and json_end > json_start:
            json_text = ai_output[json_start:json_end]
            test_cases = json.loads(json_text)
        else:
            test_cases = json.loads(ai_output)

        # Display test cases
        print(f"\nGenerated {len(test_cases)} test cases for task {task_id}:")
        for test in test_cases:
            print(f"\n--- {test['test_id']}: {test['test_name']} (Priority: {test['priority']}) ---")
            print(f"Description: {test['description']}")
            print("Steps:")
            for i, step in enumerate(test['steps'], 1):
                print(f"  {i}. {step}")
            print(f"Expected Result: {test['expected_result']}")

            # Format test case description
            steps_text = "\n".join([f"{i+1}. {step}" for i, step in enumerate(test['steps'])])
            test_description = f"""Test Case: {test['test_name']}

Description: {test['description']}

Steps:
{steps_text}

Expected Result: {test['expected_result']}

Rank: {test['priority']}
"""

            # Create subtask for test case
            test_title = f"Test: {test['test_name']} [{test['priority']}]"
            test_ticket = add_subtask(task_id, test_title, test_description)

            if test_ticket:
                created_items.append(test_ticket)
                print(f"Created test case: {test_ticket}")
                time.sleep(1)

        return created_items

    except json.JSONDecodeError as e:
        print(f"JSON parsing error: {e}")
        print(f"Raw AI response: {ai_output}")
        return []


# === Main Program ===
if __name__ == "__main__":
    # Step 1: Collect requirement from user
    requirement_text = input("Enter the task to be given to the developer: ")

    # Step 2: Create parent ticket
    print("\nCreating parent ticket...")
    main_ticket_id = add_ticket(
        f"Main Task: {requirement_text}",
        f"This is the parent ticket for: {requirement_text}\n\nSubtasks will be linked to this ticket."
    )

    if not main_ticket_id:
        print("Parent ticket creation failed. Exiting.")
        exit(1)

    # Step 3: Generate subtasks using AI
    print("\nGenerating subtasks using AI...")
    subtask_definitions = generate_tasks(requirement_text)

    task_ids = []
    task_lookup = {}

    if subtask_definitions:

        print("\nAI generated the following subtasks:")
        for i, task in enumerate(subtask_definitions, start=1):
            print(f"{i}. {task['title']}: {task['summary']}")

        # Step 4: Create tickets and link to parent
        print("\nCreating tickets and linking to parent...")
        task_ids, task_lookup = create_task_hierarchy(main_ticket_id, subtask_definitions)
    else:
        print("No subtasks were generated.")

    # Step 5: Generate test cases for each task
    if task_ids:
        print(f"\n== Creating Test Cases for {len(task_ids)} tasks ==")

        for task_id in task_ids:
            # Get task details
            task_info = task_lookup.get(task_id)

            if task_info:
                # Generate test cases for this task
                print(f"\n🔍 Processing task {task_id}: {task_info['title']}")
                test_tickets = create_test_cases(
                    task_info['summary'],
                    task_id
                )
                print(f"\nCreated {len(test_tickets)} test cases for {task_id}")
                time.sleep(2)
            else:
                print(f"Missing task data for {task_id}, skipping test generation")

    # Step 6: Show all tickets
    retrieve_tickets()
